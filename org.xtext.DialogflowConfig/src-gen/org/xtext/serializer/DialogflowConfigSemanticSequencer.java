/*
 * generated by Xtext 2.16.0
 */
package org.xtext.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.dialogflowConfig.Agent;
import org.xtext.dialogflowConfig.DialogflowConfigPackage;
import org.xtext.dialogflowConfig.Entity;
import org.xtext.dialogflowConfig.EntityType;
import org.xtext.dialogflowConfig.InputContext;
import org.xtext.dialogflowConfig.Intent;
import org.xtext.dialogflowConfig.OutputContext;
import org.xtext.dialogflowConfig.Text;
import org.xtext.dialogflowConfig.Token;
import org.xtext.dialogflowConfig.TrainingPhrase;
import org.xtext.services.DialogflowConfigGrammarAccess;

@SuppressWarnings("all")
public class DialogflowConfigSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DialogflowConfigGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DialogflowConfigPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DialogflowConfigPackage.AGENT:
				sequence_Agent(context, (Agent) semanticObject); 
				return; 
			case DialogflowConfigPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case DialogflowConfigPackage.ENTITY_TYPE:
				sequence_EntityType(context, (EntityType) semanticObject); 
				return; 
			case DialogflowConfigPackage.INPUT_CONTEXT:
				sequence_InputContext(context, (InputContext) semanticObject); 
				return; 
			case DialogflowConfigPackage.INTENT:
				sequence_Intent(context, (Intent) semanticObject); 
				return; 
			case DialogflowConfigPackage.OUTPUT_CONTEXT:
				sequence_OutputContext(context, (OutputContext) semanticObject); 
				return; 
			case DialogflowConfigPackage.PARAMETER:
				sequence_Parameter(context, (org.xtext.dialogflowConfig.Parameter) semanticObject); 
				return; 
			case DialogflowConfigPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case DialogflowConfigPackage.TOKEN:
				sequence_Token(context, (Token) semanticObject); 
				return; 
			case DialogflowConfigPackage.TRAINING_PHRASE:
				sequence_TrainingPhrase(context, (TrainingPhrase) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Agent returns Agent
	 *
	 * Constraint:
	 *     (name=ID elements+=AbstractElement*)
	 */
	protected void sequence_Agent(ISerializationContext context, Agent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns EntityType
	 *     EntityType returns EntityType
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (dynamic?='dynamic' | builtIn?='builtin' | values+=Entity+) 
	 *         isEnum?='enum'? 
	 *         ((isOverridable?='overridable' | automatedExpansion?='auto_expand' | allowFuzzyExtraction?='fuzzy_extract')? isEnum?='enum'?)*
	 *     )
	 */
	protected void sequence_EntityType(ISerializationContext context, EntityType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Entity returns Entity
	 *
	 * Constraint:
	 *     (name=STRING synonyms+=STRING*)
	 */
	protected void sequence_Entity(ISerializationContext context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputContext returns InputContext
	 *
	 * Constraint:
	 *     type=[EntityType|ID]
	 */
	protected void sequence_InputContext(ISerializationContext context, InputContext semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DialogflowConfigPackage.Literals.INPUT_CONTEXT__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DialogflowConfigPackage.Literals.INPUT_CONTEXT__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInputContextAccess().getTypeEntityTypeIDTerminalRuleCall_0_1(), semanticObject.eGet(DialogflowConfigPackage.Literals.INPUT_CONTEXT__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractElement returns Intent
	 *     Intent returns Intent
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         parameters+=Parameter* 
	 *         inputContexts+=InputContext* 
	 *         affectedContexts+=OutputContext* 
	 *         (file=STRING | (trainingPhrases+=TrainingPhrase trainingPhrases+=TrainingPhrase*))? 
	 *         responses+=STRING* 
	 *         (webHook?='webhook' | webHookForSlotFilling?='webhook_for_slot_filling')*
	 *     )
	 */
	protected void sequence_Intent(ISerializationContext context, Intent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputContext returns OutputContext
	 *
	 * Constraint:
	 *     (type=[EntityType|ID] lifespan=INT?)
	 */
	protected void sequence_OutputContext(ISerializationContext context, OutputContext semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     (type=[EntityType|ID] (required?='required' | list?='list')*)
	 */
	protected void sequence_Parameter(ISerializationContext context, org.xtext.dialogflowConfig.Parameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AbstractWord returns Text
	 *     Text returns Text
	 *
	 * Constraint:
	 *     text=STRING
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DialogflowConfigPackage.Literals.TEXT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DialogflowConfigPackage.Literals.TEXT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextAccess().getTextSTRINGTerminalRuleCall_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AbstractWord returns Token
	 *     Token returns Token
	 *
	 * Constraint:
	 *     type=[EntityType|ID]
	 */
	protected void sequence_Token(ISerializationContext context, Token semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DialogflowConfigPackage.Literals.TOKEN__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DialogflowConfigPackage.Literals.TOKEN__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTokenAccess().getTypeEntityTypeIDTerminalRuleCall_0_1(), semanticObject.eGet(DialogflowConfigPackage.Literals.TOKEN__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TrainingPhrase returns TrainingPhrase
	 *
	 * Constraint:
	 *     data+=AbstractWord+
	 */
	protected void sequence_TrainingPhrase(ISerializationContext context, TrainingPhrase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
